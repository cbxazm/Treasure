# 底层使用B+树

## 为什么不用二叉树？

```
当节点是递增顺序时，会退化成类似链表结构，查找的时间复杂度就是o(n)
```

## 为什么不用红黑树？

```
在大数据量的情况下，因为高度不可控，如果查询的节点刚好落在叶子节点，那么发生磁盘I/O的次数太多，也是不合适的。红黑树是平衡的，但是不是严格平衡，它节点左右子树要求不超过2倍，而不是1
```

## mysql取数据最小单位是页 16kb，操作系统页是4k,mysql读16k

```
每次从磁盘取出一页数据放入内存，下一次就可以直接从内存读数据，节省了磁盘I/O
对于使用B+树，每个节点就是对应的一页，取到内存中的数据比较是相当快的
减少了磁盘I/0
```

## B树

```
性质：
1.除根节点以外的任意非叶子节点最多有m个子节点，m-1个关键字
2.除根节点以外的任意非叶子节点至少有m/2 -1 个关键字(上取)
3.根节点至少1个关键字，2个子节点
4.所有的叶子节点位于同一层
```

```
相对于二叉树，每个节点存储了更多的键值（key）和数据（data）
更好的减少了磁盘I/O
```

![image-20201210160131815](C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20201210160131815.png)

## B+树

```
与B树不同的性质：
1.非叶子节点的子节点个数等于关键字个数。
2.非叶子节点的子树指针p[i],指向关键字值属于[k[i],k[i+1]]的子树(允许关键字重复)
3.所有叶子节点增加一个双向链表(本质是单向的，innodb中是双向的)
4.所有关键字都在叶子节点出现
5.非叶子节点相当于是索引值，叶子节点才是存储数据的地方
```

## 使用B+树，不使用B树的原因

```
查找数据时，最简单的肯定是顺序查找，但是对于大数据，查询效率太慢。

对于查找方式进行优化，二叉树二分查找可以将查询速度提高到logn,瓶颈在于树的深度，相当于链表，最坏情况下也是o(n)

B树每个节点都需要存放数据值

B+树的节点只需要存储key值，具体的数据都存储在叶子节点，这就使得以页为单位的索引中，可以存放更多的节点，进一步减少了磁盘i/o


1.B+树的磁盘读写代价更低，因为非叶子节点只存放key信息，可以在页大小内，存放更多的关键字

2.B+树的查询效率更加稳定：由于非叶子节点并不是存储数据的，只是存放索引，所以任何关键字的都要从根节点到叶子节点。所有关键字查询的路径长度相同，导致查询效率相当。

3.对于区间查询的情况，只需要扫一遍叶子节点，而B树需要按照中序遍历来扫一遍。

```

## 面试题

![image-20201126164656295](C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20201126164656295.png)

## myisam(非聚集（稀疏索引）)

```
索引文件跟数据文件是分离的
```

![image-20201126153932451](C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20201126153932451.png)

## innodb（聚集(聚集索引)）

## innodb表推荐使用主键

```
因为innodb表使用的是B+树底层，并且是聚集的，数据都在叶子节点上，使用主键维护的b+树

如果没有使用主键，普通索引构建的b+树(其实是非聚集的，还要去主键索引树上查找值，多了一次索引树的扫描)，叶子节点不会放其他数据，只会放主键，mysql会自动去每个列上找，如果那个列的数据值是不一样的，就会使用那列作为主键列，如果都是一样的，就会维护一个隐藏列来构建b+树

使用整型比字符串uuid比较速度快，并且整型最多占8个字节BigInt

并且使用的主键是自增的原因？

更好的维护叶子节点，因为叶子节点必须是递增的双向链表，直接一直放到后面就可以，提高insert的效率，不然可能引起分裂。
```

![image-20201126155259392](C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20201126155259392.png)

# innodb存储引擎

存储引擎就是不同的数据文件在磁盘上的不同组织形式**

https://www.zhihu.com/question/20596402?sort=created

## 回表

## 覆盖索引

## 最左匹配原则

## 索引下推

```
1.innodb是通过B+树结构对主键创建索引，然后叶子节点中存储记录，如果没有主键，那么会选择一个唯一键，如果没有唯一键，那么会生成一个6字节的row_id来作为主键。

2.如果创建索引的键是其他字段，那么在叶子节点中存储的是该记录的主键，然后再通过主键索引的B+树上找到对应的记录，叫做回表。

3.解决回表：使用覆盖索引，当普通b+树中包含要查询的所有字段时，可以不用回表，此时称之为覆盖索引
```

![image-20201210193251957](C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20201210193251957.png)

**第二条sql是不符合最左匹配原则的。直接访问age，因为是先根据name排的序，直接找age不会按照顺序来**

![image-20201210194031022](C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20201210194031022.png)



![](C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20201210194727239.png)

![image-20201210194913969](C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20201210194913969.png)

# 锁

https://blog.csdn.net/bruceleenumberone/article/details/81865045

innodb中无索行锁升级为表锁的情况

```
select * from XX where name =900  如果name是varchar类型的，并且是索引，这样就会出现索引失效情况，行锁就会升级为表锁
```



间隙锁定义

```
当我们用范围条件，而不是使用相等条件检索数据，并请求共享或排它锁时，innodb会给符合条件的已有数据进行加锁，对于在范围内但是不存在的数据，就是间隙，innodb也会对这个间隙进行加锁，这种锁机制就叫做间隙锁。


后续如果对间隙数据进行操作，也是不行的，会阻塞。
```

