# 并发

![image-20200904185105346](C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20200904185105346.png)

# 并行

![image-20200904185320780](C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20200904185320780.png)

![image-20200904185520405](C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20200904185520405.png)

# 创建线程

## 方法1

```
    Thread t=new Thread(){
          @Override
          public void run() {
              log.debug("running");
          }
      };
      t.setName("t1");
      t.start();
      log.debug("running");
    }
```

## 方法2(更加推荐，更容易跟线程池等高级api整合)

```
Runnable runnable=new Runnable() {
          @Override
          public void run() {
              log.info("run");
          }
      };
      Thread thread=new Thread(runnable，"t2");
      thread.start();
```

## lambda简化

**直接alt+insert也会有提示的**

![image-20200905125755703](C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20200905125755703.png)

```
public static void main(String[] args) {
        Runnable runnable=()->{
            System.out.println("aa");
        };
        new Thread(runnable).start();
    }
```

## Thread跟Runnable的原理

![image-20200905130939170](C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20200905130939170.png)

![image-20200905131049683](C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20200905131049683.png)

## 方法3 FutureTask配合Thread

**有返回值，适合线程间的通信**

```

//        Callable callable=()->{
//            return 100;
//        };
        //创建任务对象
        FutureTask task=new FutureTask(()->{
            Thread.sleep(2000);
          return 100;
        });
        new Thread(task,"t4").start();
        System.out.println(task.get());
```

## 查看进程线程的方法

![image-20200905141438504](C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20200905141438504.png)

**在cmd里输入jconsole,会出来图像化界面**

![image-20200905142424659](C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20200905142424659.png)

# 线程运行的原理

## 栈与栈帧

```
Java Virtual Machine Stacks （Java 虚拟机栈） 我们都知道 JVM 中由堆、栈、方法区所组成，其中栈内存是给谁用的呢？其实就是线程，每个线程启动后，虚拟 机就会为其分配一块栈内存
```

- 每个栈由多个栈帧（Frame）组成，对应着每次方法调用时所占用的内存 

- 每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法

  **图解栈帧**

  ![image-20200905143748474](C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20200905143748474.png)

## 线程上下文的切换

```
因为以下一些原因导致 cpu 不再执行当前的线程，转而执行另一个线程的代码
1.线程的 cpu 时间片用完
2.垃圾回收 
3.有更高优先级的线程需要运行
4.线程自己调用了 sleep、yield、wait、join、park、synchronized、lock 等方法

当 Context Switch 发生时，需要由操作系统保存当前线程的状态，并恢复另一个线程的状态，Java 中对应的概念 就是程序计数器（Program Counter Register），它的作用是记住下一条 jvm 指令的执行地址，是线程私有的
状态包括程序计数器、虚拟机栈中每个栈帧的信息，如局部变量、操作数栈、返回地址等 Context Switch 频繁发生会影响性能
```

#  suspend()方法为什么不推荐使用？

```
suspend()方法容易发生死锁。调用suspend()的时候，目标线程会停下来，但却仍然持有在这之前获得的锁定。此时，其他任何线程都不能访问锁定的资源，除非被”挂起”的线程恢复运行。对任何线程来说，如果它们想恢复目标线程，同时又试图使用任何一个锁定的资源，就会造成死锁。所以不应该使用suspend()，而应在自己的Thread类中置入一个标志，指出线程应该活动还是挂起。若标志指出线程应该挂起，便用 wait()命其进入等待状态。若标志指出线程应当恢复，则用一个notify()重新启动线程。
```



# 常见方法

![image-20200905145336714](C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20200905145336714.png)

![image-20200905145349051](C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20200905145349051.png)

![image-20200905145358837](C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20200905145358837.png)

## Sleep与yield

sleep

```
1. 调用 sleep 会让当前线程从 Running  进入 Timed Waiting 状态（阻塞） 
2. 其它线程可以使用  interrupt 方法打断正在睡眠的线程，这时 sleep 方法会抛出 InterruptedException 3. 睡眠结束后的线程未必会立刻得到执行 
4. 建议用 TimeUnit 的 sleep 代替 Thread 的 sleep 来获得更好的可读性 
TimeUnit.SECONDS.sleep(1) //可以指定单位
Thread.sleep(1000)//单位只能是毫秒
```

yield(不一定能谦让成功，可能还是调度到它了)

```
1. 调用 yield 会让当前线程从 Running 进入 Runnable  就绪状态，然后调度执行其它线程 
2. 具体的实现依赖于操作系统的任务调度器
```

```
package com.cbx;

import lombok.extern.slf4j.Slf4j;

/**
 * @Author:cbx
 * @Date:2020/09/05/15:05
 */
@Slf4j(topic = "c.test5")
public class test5 {
    public static void main(String[] args) {
        Thread t1=new Thread(){
            @Override
            public void run() {
                try {
                    Thread.sleep(2000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        };
        t1.start();
        log.debug("t1 state:{}",t1.getState());

        try {
            Thread.sleep(500);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        log.debug("t1 state:{}",t1.getState());
    }
}

15:08:08 [main] c.test5 - t1 state:RUNNABLE
15:08:08 [main] c.test5 - t1 state:TIMED_WAITING
```

## interrupt

```
package com.cbx;

import lombok.extern.slf4j.Slf4j;

/**
 * @Author:cbx
 * @Date:2020/09/05/15:11
 */
@Slf4j(topic = "c.cbx")
public class test6 {
    public static void main(String[] args) throws InterruptedException {
        Thread t1=new Thread("t1"){
            @Override
            public void run() {
               log.debug("enter sleep..");
                try {
                    Thread.sleep(2000);
                } catch (InterruptedException e) {
                    log.debug("wake up..");
                    e.printStackTrace();
                }
            }
        };
        t1.start();
        Thread.sleep(1000);
        log.debug("interput...");
        t1.interrupt();
    }
}

15:14:23 [t1] c.cbx - enter sleep..
15:14:24 [main] c.cbx - interput...
15:14:24 [t1] c.cbx - wake up..
java.lang.InterruptedException: sleep interrupted
	at java.lang.Thread.sleep(Native Method)
	at com.cbx.test6$1.run(test6.java:17)

```

## 线程优先级

```
线程优先级会提示（hint）调度器优先调度该线程，但它仅仅是一个提示，调度器可以忽略它

如果 cpu 比较忙，那么优先级高的线程会获得更多的时间片，但 cpu 闲时，优先级几乎没作用
```

## join方法

等待线程运行结束

```
package com.cbx;

import lombok.extern.slf4j.Slf4j;

/**
 * @Author:cbx
 * @Date:2020/09/05/15:37
 */
@Slf4j(topic = "c.cbx")
public class test7 {
    static int r=0;

    public static void main(String[] args) throws InterruptedException {
        test1();
    }

    private static void test1() throws InterruptedException {
        log.debug("开始");
        Thread t1=new Thread(()->{
            log.debug("开始");
            try {
                Thread.sleep(1);
                log.debug("结束");
                r=10;
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        },"t1");
        t1.start();
        t1.join(); //等待该线程结束再往下执行
        log.debug("结果为;{}",r);
        log.debug("结束");
    }
}

```

### join方法的同步应用

![image-20200905154630424](C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20200905154630424.png)

### join方法的限时同步

```
package com.cbx;

import lombok.extern.slf4j.Slf4j;

/**
 * @Author:cbx
 * @Date:2020/09/05/15:55
 */
@Slf4j(topic = "c.cbx")
public class test8 {
    static int r1=0;
    static int r2=0;
    public static void main(String[] args) throws InterruptedException {
        testa();
    }

    private static void testa() throws InterruptedException {
        Thread t1=new Thread(()->{
            try {
                Thread.sleep(1);
                r1=10;
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        },"t1");
       long start=System.currentTimeMillis();
       t1.start();
       t1.join(1500); //最多等待1500ms，如果在时间内，线程已经结束，那就结束等待了
       long end=System.currentTimeMillis();
       log.debug("r1: {} r2 :{} cost",r1,r2,end-start);
    }
}

```

## interrput方法

https://blog.csdn.net/cpf1040287889/article/details/90173890?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromBaidu-1.channel_param&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromBaidu-1.channel_param

### **打断sleep,join,wait的线程**

对于sleep,wait,join在被打断后，以异常的方式表示被打断，所以打断标记置为false

![](C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20200905161305856.png)

### 打断正常运行的线程

```
要根据打断标记来停止，打断只是通知一下，并没有让它停下来，通过打断标记来停止
```

![image-20200905161708792](C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20200905161708792.png)

### 两阶段终止模式interrupt

![image-20200905162851665](C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20200905162851665.png)



```
package com.cbx;

import lombok.extern.slf4j.Slf4j;

/**
 * @Author:cbx
 * @Date:2020/09/05/16:32
 */
@Slf4j(topic = "c.test9")
public class test9 {
    public static void main(String[] args) throws InterruptedException {
        TwoPhaseTermination termination=new TwoPhaseTermination();
          termination.start();
          Thread.sleep(3000);
          termination.stop();
    }

}

@Slf4j(topic = "c.Phase")
class TwoPhaseTermination{
    private Thread monitor;
    //启动监控线程
    public void start(){
        monitor=new Thread(()->{
           while(true){
             //正常打断
               Thread current=Thread.currentThread();
               if (current.isInterrupted()){
                  //不会清除打断标记(Interrupted()会清除打断标记的)
                   log.debug("继续后面的事");
                   break;
               }
               //非正常打断
               try {
                   Thread.sleep(1000); //在睡眠被打断
                   log.debug("执行监控记录"); //正常打断
               } catch (InterruptedException e) {
                   e.printStackTrace();
                   //重新设置打断标记
                   current.interrupt(); //重新设置打断标记为true
               }
           }
        });
        monitor.start();
    }

    //停止监控线程
     public void stop(){
        monitor.interrupt();
     }
}

16:44:17 [Thread-0] c.Phase - 执行监控记录
16:44:18 [Thread-0] c.Phase - 执行监控记录
java.lang.InterruptedException: sleep interrupted
	at java.lang.Thread.sleep(Native Method)
	at com.cbx.TwoPhaseTermination.lambda$start$0(test9.java:36)
	at java.lang.Thread.run(Thread.java:748)
16:44:19 [Thread-0] c.Phase - 继续后面的事


```

### 打断park线程

打断 park 线程, 不会清空打断状态

打断标记为true，park不会生效，需要置为false才会生效

```
private static void test3() throws InterruptedException 
{    Thread t1 = new Thread(
      () -> {      
     log.debug("park...");      
     LockSupport.park();      //到这边会停住(Interrupt会打断该状态，让它往下) 
     log.debug("unpark...");      
     log.debug("打断状态：{}", Thread.currentThread().isInterrupted());  
    //下面会继续执行，因为打断标记没有清空，isInterrupted()方法不会清空打断标记
    LockSupport.park(); 
     log.debug("unpark..."); 
    }, "t1");    
    t1.start();
 
 
    sleep(0.5);    
    t1.interrupt();
    
    }
    
    21:11:52.795 [t1] c.TestInterrupt - park... 
    21:11:53.295 [t1] c.TestInterrupt - unpark... 
    21:11:53.295 [t1] c.TestInterrupt - 打断状态：true 


```



## stop方法

```
会真正的杀死线程，如果这时线程锁住了共享资源，那么当它被杀死后就没有机会释放锁，其他线程永远无法获取锁
```

## 守护线程

![image-20200905185030437](C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20200905185030437.png)

# 不推荐的方法

**容易让锁得不到释放，造成死锁**

![image-20200905184532577](C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20200905184532577.png)

# 五种线程状态

![image-20200905185634425](C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20200905185634425.png)

![image-20200905185703809](C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20200905185703809.png)

## java里的六种状态

![image-20201008200813811](C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20201008200813811.png)

```
package com.cbx;

import lombok.extern.slf4j.Slf4j;

/**
 * @Author:cbx
 * @Date:2020/09/06/12:55
 */
@Slf4j(topic = "c.cbx")
public class testa {
    public static void main(String[] args) {
        Thread t1=new Thread("t1"){
            @Override
            public void run() {
                log.debug("running...");
            }
        };
        Thread t2=new Thread("t2"){
            @Override
            public void run() {
                while (true){

                }
            }
        };
        t2.start();


        Thread t3=new Thread("t3"){
            @Override
            public void run() {
                log.debug("running");
            }
        };
        t3.start();


        Thread t4=new Thread("t4"){
            @Override
            public void run() {
                synchronized (testa.class){
                    try {
                         Thread.sleep(100000);
                    }catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            }
        };
        t4.start();

        Thread t5=new Thread("t5"){
            @Override
            public void run() {
                try {
                    t2.join();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        };
        t5.start();

        Thread t6=new Thread("t6"){
            @Override
            public void run() {
                synchronized (testa.class){
                    try {
                        Thread.sleep(10000);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            }
        };
        t6.start();

        log.debug("t1 state {}",t1.getState());
        log.debug("t2 state {}",t2.getState());
        log.debug("t3 state {}",t3.getState());
        log.debug("t4 state {}",t4.getState());
        log.debug("t5 state {}",t5.getState());
        log.debug("t6 state {}",t6.getState());  //上面的锁还没有释放
    }
}


13:07:09 [main] c.cbx - t1 state NEW
13:07:09 [t3] c.cbx - running
13:07:09 [main] c.cbx - t2 state RUNNABLE
13:07:09 [main] c.cbx - t3 state TERMINATED
13:07:09 [main] c.cbx - t4 state TIMED_WAITING
13:07:09 [main] c.cbx - t5 state WAITING
13:07:09 [main] c.cbx - t6 state BLOCKED
```

# 烧水泡茶案列

## 解法1 join

```
办法甲：洗好水壶，灌上凉水，放在火上；在等待水开的时间里，洗茶壶、洗茶杯、拿茶叶；等水开 了，泡茶喝。 

办法乙：先做好一些准备工作，洗水壶，洗茶壶茶杯，拿茶叶；一切就绪，灌水烧水；坐待水开了，泡 茶喝。

办法丙：洗净水壶，灌上凉水，放在火上，坐待水开；水开了之后，急急忙忙找茶叶，洗茶壶茶杯，泡 茶喝。

```

```
Thread t1 = new Thread(() -> {  
    log.debug("洗水壶"); 
    sleep(1);   
    log.debug("烧开水");  
    sleep(15);
}, "老王");
 
Thread t2 = new Thread(() -> {   
    log.debug("洗茶壶");  
    sleep(1);   
    log.debug("洗茶杯");   
    sleep(2);    
    log.debug("拿茶叶");    
    sleep(1);   
    try {      
    t1.join();    
} catch (InterruptedException e) {    
e.printStackTrace();  
}  
    log.debug("泡茶"); 
}, "小王");
 
t1.start();
t2.start();

19:19:37.547 [小王] c.TestMakeTea - 洗茶壶 
19:19:37.547 [老王] c.TestMakeTea - 洗水壶 
19:19:38.552 [小王] c.TestMakeTea - 洗茶杯 
19:19:38.552 [老王] c.TestMakeTea - 烧开水 
19:19:40.553 [小王] c.TestMakeTea - 拿茶叶
19:19:53.553 [小王] c.TestMakeTea - 泡茶
```

### 缺陷

```
上面模拟的是小王等老王的水烧开了，小王泡茶，如果反过来要实现老王等小王的茶叶拿来了，老王泡茶 呢？

代码最好能适应两种情况 上面的两个线程其实是各执行各的，

如果要模拟老王把水壶交给小王泡茶，或模拟小王把茶叶交给老王泡茶 呢
```



# 共享模型 --- 管程

## 共享带来的问题

![image-20200906141523461](C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20200906141523461.png)

![image-20200906141534538](C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20200906141534538.png)

![image-20200906141547097](C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20200906141547097.png)

![image-20200906141557020](C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20200906141557020.png)

## java的体现

两个线程对初始值为 0 的静态变量一个做自增，一个做自减，各做 5000 次，结果是 0 吗

```
  static int counter = 0;

    public static void main(String[] args) throws InterruptedException {   
        Thread t1 = new Thread(() -> {     
            for (int i = 0; i < 5000; i++) {     
                counter++;       
            }    }, "t1");

        Thread t2 = new Thread(() -> {    
            for (int i = 0; i < 5000; i++) {          
                counter--;        }   
                }, "t2");

        t1.start();   
        t2.start();   
        t1.join();  
        t2.join();   
        log.debug("{}",counter); }
```

以上的结果可能是正数、负数、零。为什么呢？因为 Java 中对静态变量的自增，自减并不是原子操作，要彻底理 解，必须从字节码来进行分析
例如对于 i++ 而言（i 为静态变量），实际会产生如下的 JVM 字节码指令

```
getstatic     i  // 获取静态变量i的值 
iconst_1      // 准备常量1 
iadd         // 自增 
putstatic     i  // 将修改后的值存入静态变量i
```

而对应 i-- 也是类似

```
getstatic     i  // 获取静态变量i的值 
iconst_1         // 准备常量1 
isub             // 自减
putstatic     i  // 将修改后的值存入静态变量i
```

![image-20200906141902694](C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20200906141902694.png)

**正常情况**

![image-20200906141930974](C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20200906141930974.png)

**负数情况**

![image-20200906142010455](C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20200906142010455.png)

**正数情况**

![image-20200906142025952](C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20200906142025952.png)

## 临界区（对共享资源发生读写操作了，如果只有读，不算临界区）

```
临界区 Critical Section 
一个程序运行多个线程本身是没有问题的 问题出在多个线程访问共享资源 多个线程读共享资源其实也没有问题 

在多个线程对共享资源读写操作时发生指令交错，就会出现问题 一段代码块内如果存在对共享资源的多线程**读写**操作，称这段代码块为临界区

例如，下面代码中的临界区
static int counter = 0;
 
static void increment() // 临界区 {  

  counter++;
  
}
 
static void decrement() // 临界区 {   

   counter--; 

}
```



## synchronized解决方案

```
为了避免临界区的竞态条件发生，有多种手段可以达到目的。

阻塞式的解决方案：synchronized，Lock

非阻塞式的解决方案：原子变量

本次课使用阻塞式的解决方案：synchronized，来解决上述问题，即俗称的【对象锁】，它采用互斥的方式让同一 时刻至多只有一个线程能持有【对象锁】，其它线程再想获取这个【对象锁】时就会阻塞住。这样就能保证拥有锁 的线程可以安全的执行临界区内的代码，不用担心线程上下文切换
```

![image-20200906143003514](C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20200906143003514.png)

![image-20200906143316212](C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20200906143316212.png)

**语法**

```
synchronized(对象) // 线程1， 线程2(blocked)
{ 
临界区 
}
```

```
static int counter = 0; 
static final Object room = new Object();
 
public static void main(String[] args) throws InterruptedException {  
Thread t1 = new Thread(() -> {    
    for (int i = 0; i < 5000; i++) {      
    synchronized (room) {      
            counter++;          
            }      
        }   
    }, "t1");
 
    Thread t2 = new Thread(() -> {   
    for (int i = 0; i < 5000; i++) {   
        synchronized (room) {       
                counter--;          
            }     
                }   
        }, "t2");
 
    t1.start();   
    t2.start();  
    t1.join();    
    t2.join();    
    log.debug("{}",counter); }
```

## 方法上的synchronized

![image-20200906144624840](C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20200906144624840.png)

## 变量的线程安全问题

### 成员变量和静态变量是否线程安全？

```
如果它们没有共享，则线程安全 如果它们被共享了，根据它们的状态是否能够改变，又分两种情况 

如果只有读操作，则线程安全 

如果有读写操作，则这段代码是临界区，需要考虑线程安全

```

### 局部变量是否线程安全?

```
局部变量是线程安全的 但局部变量引用的对象则未必

如果该对象没有逃离方法的作用访问，它是线程安全的

如果该对象逃离方法的作用范围，需要考虑线程安全
```

#### 局部变量线程安全分析

```
public static void test1() {   
   int i = 10; 
   i++
  }
  每个线程调用 test1() 方法时局部变量 i，会在每个线程的栈帧内存中被创建多份，因此不存在共享
```

**成员变量线程不安全**

```
package com.cbx;

import java.util.ArrayList;

/**
 * @Author:cbx
 * @Date:2020/09/06/16:18
 */
public class testb {
    public static void main(String[] args) {
        ThreadUnSafe unSafe=new ThreadUnSafe();
        for (int i = 0; i < 2; i++) {
            new Thread(()->{
                unSafe.method1(200);
            }).start();
        }
    }
}
class ThreadUnSafe{
    ArrayList<String> list=new ArrayList<>();
    public void method1(int loopNumber){
        for (int i = 0; i < loopNumber; i++) {
            method2();
             method3();
        }
    }

    private void method3() {
        list.add("1");
    }

    private void method2() {
        list.remove(0);
    }
}

java.lang.IndexOutOfBoundsException: Index: 0, Size: 0
	at java.util.ArrayList.rangeCheck(ArrayList.java:657)
	at java.util.ArrayList.remove(ArrayList.java:496)
	at com.cbx.ThreadUnSafe.method2(testb.java:33)
	at com.cbx.ThreadUnSafe.method1(testb.java:23)
	at com.cbx.testb.lambda$main$0(testb.java:14)
	at java.lang.Thread.run(Thread.java:748)
```

![image-20200906162344506](C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20200906162344506.png)

**局部变量线程安全情况**

```
class ThreadSafe{

    public void method1(int loopNumber){
        ArrayList<String> list=new ArrayList<>();
        for (int i = 0; i < loopNumber; i++) {
            method2(list);
            method3(list);
        }
    }

    private void method3(ArrayList<String> list) {
        list.add("1");
    }

    private void method2(ArrayList<String> list) {
        list.remove(0);
    }
}
public static void main(String[] args) {
        ThreadSafe Safe=new ThreadSafe();
        for (int i = 0; i < 2; i++) {
            new Thread(()->{
                Safe.method1(200);
            }).start();
        }
    }

```

![image-20200906162837035](C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20200906162837035.png)

#### 局部变量暴露引用

![image-20200906163756901](C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20200906163756901.png)



## 常见的线程安全类

```
String 

Integer

 StringBuﬀer 

Random

 Vector 

Hashtable

 java.util.concurrent 包下的类
```

这里说它们是线程安全的是指，多个线程调用它们同一个实例的某个方法时，是线程安全的。也可以理解为

```
Hashtable table = new Hashtable();
 
new Thread(()->{   
table.put("key", "value1"); }).start();
 
new Thread(()->{   
table.put("key", "value2"); }).start()
```

**方法组合就不一定是原子的了**

![image-20200906164854562](C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20200906164854562.png)

# 卖票练习和转账练习(见并发编程pdf)

# Monitor概念

## 查看对象头markword的工具

![image-20201208145635935](C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20201208145635935.png)

## Java对象头

![image-20200906202116829](C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20200906202116829.png)

![image-20200930162545012](C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20200930162545012.png)

![image-20200906202326252](C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20200906202326252.png)

## 轻量级锁

## 锁膨胀

## 自旋优化

## 偏向锁

## 锁消除

# wait--notify原理

![image-20200908202155145](C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20200908202155145.png)



```
obj.wait() 让进入 object 监视器的线程到 waitSet 等待 

obj.notify() 在 object 上正在 waitSet 等待的线程中挑一个唤醒 

obj.notifyAll() 让 object 上正在 waitSet 等待的线程全部唤

它们都是线程之间进行协作的手段，都属于 Object 对象的方法。必须获得此对象的锁，才能调用这几个方法
 
```

```
package com.cbx;

import lombok.extern.slf4j.Slf4j;

/**
 * @Author:cbx
 * @Date:2020/09/08/20:25
 */
@Slf4j(topic = "c.cbx")
public class testc {
    final static Object obj=new Object();

    public static void main(String[] args) throws InterruptedException {
        new Thread(()->{
           synchronized (obj){
               log.debug("执行...");
               try {
                   //让线程在obj上一直等待下去
                   obj.wait(); //把锁释放给其他线程
               } catch (InterruptedException e) {
                   e.printStackTrace();
               }
               log.debug("其他");
           }
        },"t0").start();
        new Thread(()->{
            synchronized (obj){
                log.debug("执行");
                try {
                    obj.wait();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                log.debug("其他");
            }

        },"t1").start();

        //主线程两秒后执行
        Thread.sleep(2000);
        log.debug("唤醒obj上其他的线程");
        synchronized (obj){
//            obj.notify();//唤醒一个
            obj.notifyAll();
        }
    }
}

```

## sleep和wait的区别

```
1) sleep 是 Thread 方法，而 wait 是 Object 的方法 
2) sleep 不需要强制和 synchronized 配合使用，但 wait 需要 和 synchronized 一起用 
3) sleep 在睡眠的同时，不会释放对象锁的，但 wait 在等待的时候会释放对象锁 
4) 它们 状态 TIMED_WAITING
```

## 正确姿势

```
synchronized(lock) {   
    while(条件不成立) {        
    lock.wait();  
}    // 干活 }
 
//另一个线程 synchronized(lock) {  
        lock.notifyAll(); 
}
```

# 同步模式之保护性暂停

![image-20200908210736186](C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20200908210736186.png)

```
package com.cbx;

import lombok.extern.slf4j.Slf4j;

import java.util.List;

/**
 * @Author:cbx
 * @Date:2020/09/08/21:12
 */
@Slf4j(topic = "c.cbx")
public class testd {
    public static void main(String[] args) {
        GuardObject object=new GuardObject();
;        new Thread(()->{
             log.debug("获取结果");
            List<String> list =(List<String>) object.get();
            log.debug("结果大小{}",list.size());
        },"t1").start();
        new Thread(()->{
            log.debug("执行下载");
            List<String> list=null;
            try {
                 list=Downloader.download();
            } catch (Exception e) {
                e.printStackTrace();
            }
            object.complete(list);
        }).start();
    }
}

class GuardObject{
    //结果
    private Object response;

    //获取结果的方法
    public Object get(){
        synchronized (this){
            while (response==null){
                try {
                    this.wait();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }
        return response;
    }
     //产生结果
    public void complete(Object response){
        synchronized (this){
            this.response=response;
            this.notifyAll();
        }
    }
}

```

## join()的原理就是wait(增强超时时间版的wait)

![image-20200908220126792](C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20200908220126792.png)

# 异步模式---生产者消费者模式

**代码见并发编程模式**

![image-20200914124729186](C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20200914124729186.png)



# park&unpark

```
wait，notify 和 notifyAll 必须配合 Object Monitor 一起使用，而 park，unpark 不必

park & unpark 是以线程为单位来【阻塞】和【唤醒】线程，而 notify 只能随机唤醒一个等待线程，notifyAll 是唤醒所有等待线程，就不那么【精确]

park & unpark 可以先 unpark，而 wait & notify 不能先 notify（先unpark这个线程后再park，这个线程不会阻塞）
```

## 原理

```
每个线程都有自己的一个 Parker 对象，由三部分组成 _counter ， _cond 和 _mutex 打个比喻 
线程就像一个旅人，Parker 就像他随身携带的背包，条件变量就好比背包中的帐篷

。_counter 就好比背包中 的备用干粮（0 为耗尽，1 为充足） 调用 park 就是要看需不需要停下来歇息 

如果备用干粮耗尽，那么钻进帐篷歇息 如果备用干粮充足，那么不需停留，继续前进 

调用 unpark，就好比令干粮充足 如果这时线程还在帐篷，就唤醒让他继续前进 

如果这时线程还在运行，那么下次他调用 park 时，仅是消耗掉备用干粮，不需停留继续前进 因为背包空间有限，多次调用 unpark 仅会补充一份备用干
```

## 先调用park后unpark

![image-20200914141931903](C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20200914141931903.png)

## 先调用unpark后park

![image-20200914142002271](C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20200914142002271.png)

![image-20200914142017694](C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20200914142017694.png)

# 活跃性

## 1.死锁(阻塞住)

```
有这样的情况：一个线程需要同时获取多把锁，这时就容易发生死锁
t1 线程 获得 A对象 锁，接下来想获取 B对象 的锁 t2 线程 获得 B对象 锁，接下来想获取 A对象 的锁 例：
```

![image-20200915144840530](C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20200915144840530.png)

![image-20200915144852032](C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20200915144852032.png)

### 哲学家就餐问题(见pdf)

## 2.活锁(永远停不下来)

```
活锁出现在两个线程互相改变对方的结束条件，后谁也无法结束，
```

![image-20200915150202706](C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20200915150202706.png)

## 3.饥饿

# ReentrantLock(可重入锁)

```
相对于 synchronized 它具备如下特点
    .可中断
    .可以设置超时时间 
    .可以设置为公平锁
    .支持多个条件变量（就是相当于有多个休息室waitset的意思）
与 synchronized 一样，都支持可重入(就是对同一个对象反复的加锁)
```

## 可重入

```
可重入是指同一个线程如果首次获得了这把锁，那么因为它是这把锁的拥有者，因此有权利再次获取这把锁
如果是不可重入锁，那么第二次获得锁时，自己也会被锁挡住
```

![image-20200915152249389](C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20200915152249389.png)

## 可打断

![image-20200915153036234](C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20200915153036234.png)

## 锁超时

### 立即失败

![image-20200915154124937](C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20200915154124937.png)

![image-20200915154137488](C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20200915154137488.png)

### 超时失败

![image-20200915154222889](C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20200915154222889.png)

## 公平锁

```
ReentrantLock 默认是不公平  (一般没有必要使用公平锁，会降低并发度)

ReentrantLock lock = new ReentrantLock(true)； 

改为公平锁后，会按照进入entryList的线程的顺序来分配锁，不会随机分配(先入先得)
```

## 条件变量

```
synchronized 中也有条件变量，就是我们讲原理时那个 waitSet 休息室，当条件不满足时进入 waitSet 等待 

ReentrantLock 的条件变量比 synchronized 强大之处在于，它是支持多个条件变量的，

这就好比 synchronized 是那些不满足条件的线程都在一间休息室等消息 

而 ReentrantLock 支持多间休息室，有专门等烟的休息室、专门等早餐的休息室、唤醒时也是按休息室来唤 醒
```

**使用要点**

```
await 前需要获得锁 

await 执行后，会释放锁，进入 conditionObject 等待

await 的线程被唤醒（或打断、或超时）取重新竞争 lock 锁 

竞争 lock 锁成功后，从 await 后继续执行
```

![image-20200915162148330](C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20200915162148330.png)

![image-20200915162201724](C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20200915162201724.png)

![image-20200915162213980](C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20200915162213980.png)

# 同步模式之顺序控制

## wait&notify版

![image-20200915162750911](C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20200915162750911.png)

## park&unpark版

![image-20200915163202259](C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20200915163202259.png)

## 交替输出

```
线程 1 输出 a 5 次，线程 2 输出 b 5 次，线程 3 输出 c 5 次。现在要求输出 abcabcabcabcabc 怎么实现
```

### wait&notify版

![image-20200915164334466](C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20200915164334466.png)

### lock条件变量版

![image-20200915181747473](C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20200915181747473.png)

![image-20200915181758822](C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20200915181758822.png)

![image-20200915181812168](C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20200915181812168.png)

### park&unpark版

![image-20200915182646767](C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20200915182646767.png)

![image-20200915182657189](C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20200915182657189.png)

# JMM(Java Memory Model)java内存模型

```
JMM 即 Java Memory Model，它定义了主存、工作内存抽象概念，底层对应着 CPU 寄存器、缓存、硬件内存、 CPU 指令优化等

原子性 - 保证指令不会受到线程上下文切换的影响 

可见性 - 保证指令不会受 cpu 缓存的影响

有序性 - 保证指令不会受 cpu 指令并行优化的影响
```

## 可见性

### 退不出循环问题

![image-20200915184049900](C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20200915184049900.png)

1. 初始状态， t 线程刚开始从主内存读取了 run 的值到工作内存。

   ![image-20200915184114188](C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20200915184114188.png)

2. 因为 t 线程要频繁从主内存中读取 run 的值，JIT 编译器会将 run 的值缓存至自己工作内存中的高速缓存中， 减少对主存中 run 的访问，提高效率。

   ![image-20200915184134479](C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20200915184134479.png)

3. 1 秒之后，main 线程修改了 run 的值，并同步至主存，而 t 是从自己工作内存中的高速缓存中读取这个变量 的值，结果永远是旧值。

   ![image-20200915184154828](C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20200915184154828.png)

### 解决方法 volatile关键字

```
它可以用来修饰成员变量和静态成员变量，他可以避免线程从自己的工作缓存中查找变量的值，必须到主存中获取 它的值，线程操作 volatile 变量都是直接操作主存 
```

## 可见性vs原子性

![image-20200915185227512](C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20200915185227512.png)

```
注意 synchronized 语句块既可以保证代码块的原子性，也同时保证代码块内变量的可见性。但缺点是 synchronized 是属于重量级操作，性能相对更
```

## 两阶段终止模式(volatile标记版)

![image-20200915190259116](C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20200915190259116.png)

## 有序性

### 指令重排

# volatile底层原理

```
volatile 的底层实现原理是内存屏障，Memory Barrier（Memory Fence）

对 volatile 变量的写指令后会加入写屏障 

对 volatile 变量的读指令前会加入读屏障
```

![image-20200915220926919](C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20200915220926919.png)

![image-20200915220941672](C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20200915220941672.png)

## 多线程中解决不了指令交错

```
还是那句话，不能解决指令交错：

写屏障仅仅是保证之后的读能够读到新的结果，但不能保证读跑到它前面去 

而有序性的保证也只是保证了本线程内相关代码不被重排
```

![image-20200915221213898](C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20200915221213898.png)

# Double-check locking

```
package com.cbx;

/**
 * @Author:cbx
 * @Date:2020/09/15/22:20
 */
public class DoubleCheck {
    private DoubleCheck(){};
    private static volatile DoubleCheck INSTANCE=null;

    private static DoubleCheck getInstance(){
        if (INSTANCE==null){
        //这里的INSTANCE没有在synchronized块里面，会出现指令重排的现象
         // 首次访问会同步，而之后的使用没有 synchronized
            synchronized (DoubleCheck.class){
                if (INSTANCE==null){
                    INSTANCE=new DoubleCheck();
                }
            }
        }
        return INSTANCE;
    }
}

```

## 出现指令重排的问题

![image-20200915223858541](C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20200915223858541.png)

## 解决方法(使用volatile)

![image-20200915224026235](C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20200915224026235.png)

# 共享模型之无锁

## CAS(底层需要配合volatile关键字)

![image-20200916132030906](C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20200916132030906.png)

![image-20200916131902796](C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20200916131902796.png)

## 为什么无锁的效率高

```
无锁情况下，即使重试失败，线程始终在高速运行，没有停歇，而 synchronized 会让线程在没有获得锁的时 候，发生上下文切换，进入阻塞。打个比喻 

线程就好像高速跑道上的赛车，高速运行时，速度超快，一旦发生上下文切换，就好比赛车要减速、熄火， 等被唤醒又得重新打火、启动、加速... 恢复到高速运行，代价比较大

但无锁情况下，因为线程要保持运行，需要额外 CPU 的支持，CPU 在这里就好比高速跑道，没有额外的跑 道，线程想高速运行也无从谈起，虽然不会进入阻塞，但由于没有分到时间片，仍然会进入可运行状态，还是会导致上下文切换
```

## CAS的特点

```
结合 CAS 和 volatile 可以实现无锁并发，适用于线程数少、多核 CPU 的场景下。

CAS 是基于乐观锁的思想：乐观的估计，不怕别的线程来修改共享变量，就算改了也没关系，我吃亏点再 重试呗。 

synchronized 是基于悲观锁的思想：悲观的估计，得防着其它线程来修改共享变量，我上了锁你们都别想 改，我改完了解开锁，你们才有机会。 

CAS 体现的是无锁并发、无阻塞并发，请仔细体会这两句话的意思 

因为没有使用 synchronized，所以线程不会陷入阻塞，这是效率提升的因素之一

但如果竞争激烈，可以想到重试必然频繁发生，反而效率会受影响
```

## 原子整数

```
J.U.C 并发包提供了：
AtomicBoolean

AtomicInteger

AtomicLong
```

![image-20200916134720192](C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20200916134720192.png)

## 原子引用

```
AtomicReference 

AtomicMarkableReference 

AtomicStampedReference
```

![image-20200916140213388](C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20200916140213388.png)

### ABA问题

```
主线程感知不到中间发生的变化，只要最后还是那个数就会cas成功
```

![image-20200916140834243](C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20200916140834243.png)

### ABA问题的解决(AtomicStampedReference)

![image-20200916141345462](C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20200916141345462.png)

​          上面的版本号必须是0才对的上，下面已经把版本号更新为2

![image-20200916141357232](C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20200916141357232.png)

### AtomicMarkableReference（使用boolean来判断，无需记录版本号）

![image-20200916142757456](C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20200916142757456.png)

![image-20200916143017466](C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20200916143017466.png)

## 原子数组

```
AtomicIntegerArray 

AtomicLongArray 

AtomicReferenceArray
```

## 字段更新器

```
利用字段更新器，可以针对对象的某个域（Field）进行原子操作，只能配合 volatile 修饰的字段使用，否则会出现 异常
AtomicReferenceFieldUpdater // 域  字段 
AtomicIntegerFieldUpdater
AtomicLongFieldUpdate
```

![image-20200916144853280](C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20200916144853280.png)

## 原子累加器(LongAdder) 性能较高

```
性能高于原子整数的累加
```

# 享元模式

```
 英文名称：Flyweight pattern. 当需要重用数量有限的同一类对象时
```

## 包装类

![image-20200916215155748](C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20200916215155748.png)

![image-20200916215335824](C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20200916215335824.png)

## String串池

## BigDecimal BigInteger

# 自定义连接池

```
package com.cbx;

import lombok.extern.slf4j.Slf4j;

import java.sql.*;
import java.util.Map;
import java.util.Properties;
import java.util.Random;
import java.util.concurrent.Executor;
import java.util.concurrent.atomic.AtomicIntegerArray;

/**
 * @Author:cbx
 * @Date:2020/09/16/21:59
 */

class test2432423{
    public static void main(String[] args) {
        Pool pool=new Pool(2);
        for (int i = 0; i < 5; i++) {
            new Thread(()->{
                Connection conn=pool.borrow();
                try {
                    Thread.sleep(new Random().nextInt(1000));
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                pool.free(conn);
            }).start();
        }
    }
}
@Slf4j(topic = "c.cbx")
public class Pool {
    //连接池大小
    private final int poolSize;

    //连接数组
    private Connection[] connections;

    //连接状态数组 0表示空闲 1表示繁忙
    private AtomicIntegerArray states;

    //构造方法初始化
    public Pool(int poolSize){
        this.poolSize=poolSize;
        this.connections=new Connection[poolSize];
        this.states=new AtomicIntegerArray(new int[poolSize]);
        for (int i = 0; i < poolSize; i++) {
            connections[i]=new MockConnection("连接"+i);
        }
    }

    //借连接
    public Connection borrow(){
        while (true){
            for (int i = 0; i < poolSize; i++) {
                if (states.get(i)==0){
                    if (states.compareAndSet(i,0,1)) {
                        log.debug("获取{}",connections[i]);
                        return connections[i];
                    }
                }
            }
            //如果没有空闲,当前线程进入等待
            synchronized (this){
                try {
                    log.debug("wait..");
                    this.wait();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }
    }

    //归还连接
    public void free(Connection conn){
        for (int i = 0; i < poolSize; i++) {
            if (connections[i]==conn) {
                states.set(i,0);
                synchronized (this){
                    log.debug("free{}",conn);
                    this.notifyAll();
                }
                break;
            }
        }

    }


}

class MockConnection implements Connection{
    private String name;
    public MockConnection(String name){
        this.name=name;
    }

    @Override
    public String toString() {
        return "MockConnection{" +
                "name='" + name + '\'' +
                '}';
    }

    @Override
    public Statement createStatement() throws SQLException {
        return null;
    }

    @Override
    public PreparedStatement prepareStatement(String sql) throws SQLException {
        return null;
    }

    @Override
    public CallableStatement prepareCall(String sql) throws SQLException {
        return null;
    }

    @Override
    public String nativeSQL(String sql) throws SQLException {
        return null;
    }

    @Override
    public void setAutoCommit(boolean autoCommit) throws SQLException {

    }

    @Override
    public boolean getAutoCommit() throws SQLException {
        return false;
    }

    @Override
    public void commit() throws SQLException {

    }

    @Override
    public void rollback() throws SQLException {

    }

    @Override
    public void close() throws SQLException {

    }

    @Override
    public boolean isClosed() throws SQLException {
        return false;
    }

    @Override
    public DatabaseMetaData getMetaData() throws SQLException {
        return null;
    }

    @Override
    public void setReadOnly(boolean readOnly) throws SQLException {

    }

    @Override
    public boolean isReadOnly() throws SQLException {
        return false;
    }

    @Override
    public void setCatalog(String catalog) throws SQLException {

    }

    @Override
    public String getCatalog() throws SQLException {
        return null;
    }

    @Override
    public void setTransactionIsolation(int level) throws SQLException {

    }

    @Override
    public int getTransactionIsolation() throws SQLException {
        return 0;
    }

    @Override
    public SQLWarning getWarnings() throws SQLException {
        return null;
    }

    @Override
    public void clearWarnings() throws SQLException {

    }

    @Override
    public Statement createStatement(int resultSetType, int resultSetConcurrency) throws SQLException {
        return null;
    }

    @Override
    public PreparedStatement prepareStatement(String sql, int resultSetType, int resultSetConcurrency) throws SQLException {
        return null;
    }

    @Override
    public CallableStatement prepareCall(String sql, int resultSetType, int resultSetConcurrency) throws SQLException {
        return null;
    }

    @Override
    public Map<String, Class<?>> getTypeMap() throws SQLException {
        return null;
    }

    @Override
    public void setTypeMap(Map<String, Class<?>> map) throws SQLException {

    }

    @Override
    public void setHoldability(int holdability) throws SQLException {

    }

    @Override
    public int getHoldability() throws SQLException {
        return 0;
    }

    @Override
    public Savepoint setSavepoint() throws SQLException {
        return null;
    }

    @Override
    public Savepoint setSavepoint(String name) throws SQLException {
        return null;
    }

    @Override
    public void rollback(Savepoint savepoint) throws SQLException {

    }

    @Override
    public void releaseSavepoint(Savepoint savepoint) throws SQLException {

    }

    @Override
    public Statement createStatement(int resultSetType, int resultSetConcurrency, int resultSetHoldability) throws SQLException {
        return null;
    }

    @Override
    public PreparedStatement prepareStatement(String sql, int resultSetType, int resultSetConcurrency, int resultSetHoldability) throws SQLException {
        return null;
    }

    @Override
    public CallableStatement prepareCall(String sql, int resultSetType, int resultSetConcurrency, int resultSetHoldability) throws SQLException {
        return null;
    }

    @Override
    public PreparedStatement prepareStatement(String sql, int autoGeneratedKeys) throws SQLException {
        return null;
    }

    @Override
    public PreparedStatement prepareStatement(String sql, int[] columnIndexes) throws SQLException {
        return null;
    }

    @Override
    public PreparedStatement prepareStatement(String sql, String[] columnNames) throws SQLException {
        return null;
    }

    @Override
    public Clob createClob() throws SQLException {
        return null;
    }

    @Override
    public Blob createBlob() throws SQLException {
        return null;
    }

    @Override
    public NClob createNClob() throws SQLException {
        return null;
    }

    @Override
    public SQLXML createSQLXML() throws SQLException {
        return null;
    }

    @Override
    public boolean isValid(int timeout) throws SQLException {
        return false;
    }

    @Override
    public void setClientInfo(String name, String value) throws SQLClientInfoException {

    }

    @Override
    public void setClientInfo(Properties properties) throws SQLClientInfoException {

    }

    @Override
    public String getClientInfo(String name) throws SQLException {
        return null;
    }

    @Override
    public Properties getClientInfo() throws SQLException {
        return null;
    }

    @Override
    public Array createArrayOf(String typeName, Object[] elements) throws SQLException {
        return null;
    }

    @Override
    public Struct createStruct(String typeName, Object[] attributes) throws SQLException {
        return null;
    }

    @Override
    public void setSchema(String schema) throws SQLException {

    }

    @Override
    public String getSchema() throws SQLException {
        return null;
    }

    @Override
    public void abort(Executor executor) throws SQLException {

    }

    @Override
    public void setNetworkTimeout(Executor executor, int milliseconds) throws SQLException {

    }

    @Override
    public int getNetworkTimeout() throws SQLException {
        return 0;
    }

    @Override
    public <T> T unwrap(Class<T> iface) throws SQLException {
        return null;
    }

    @Override
    public boolean isWrapperFor(Class<?> iface) throws SQLException {
        return false;
    }
}

```

![image-20200916222638190](C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20200916222638190.png)

# 自定义线程池

![image-20200917160845908](C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20200917160845908.png)

```
package com.cbx;

import com.sun.xml.internal.bind.v2.model.annotation.RuntimeAnnotationReader;
import javafx.concurrent.Worker;
import lombok.extern.slf4j.Slf4j;

import java.util.ArrayDeque;
import java.util.Deque;
import java.util.HashSet;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;

/**
 * @Author:cbx
 * @Date:2020/09/17/15:57
 * 自定义线程池
 */
@Slf4j(topic = "c.cbxSelfPool")
public class SelfPool {
    public static void main(String[] args) {
        ThreadPool threadPool=new ThreadPool(2,1000,TimeUnit.MILLISECONDS,10,
                (queue,task)->{
                      //1.死等
//                     qu eue.put(task);
//                     2. 有时限的等待
                    queue.offer(task,1000,TimeUnit.MILLISECONDS);
        });
        for (int i = 0; i < 15; i++) {
            int j=i;
            threadPool.execute(()->{
                try {
                    Thread.sleep(1000000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                log.debug("{}",j);
            });
        }
    }
}

@FunctionalInterface
interface RejectPolicy<T>{
    void reject(BlockingQueue<T> queue, T task);
}

/**
 * 自定义的线程池类
 */
@Slf4j(topic = "c.cbxThredPool")
class ThreadPool{
   //任务队列
    private BlockingQueue<Runnable> taskQueue;

    //线程集合
    private HashSet<Worker> workers=new HashSet<>();

    //核心线程数
    private int coreSize;

    //获取任务的超时时间
    private long timeout;

    private TimeUnit timeUnit;
    
    private RejectPolicy<Runnable> rejectPolicy;

    public ThreadPool(int coreSize,long timeout,TimeUnit timeUnit,int queueCapcity,RejectPolicy rejectPolicy){
         this.coreSize=coreSize;
         this.timeout=timeout;
         this.timeUnit=timeUnit;
         this.taskQueue=new BlockingQueue<>(queueCapcity);
         this.rejectPolicy=rejectPolicy;
    }

    //执行任务
    public void execute(Runnable task){
        //任务数没有超过核心线程数，就直接交给worker执行
        //超过了就放在任务队列
       synchronized (workers){
           if (workers.size()<coreSize){
               Worker worker=new Worker(task);
               log.debug("新增worker{},task {}",worker,task);
               workers.add(worker);
               worker.start();
           }else {
               //加入任务队列
//               taskQueue.put(task);
               taskQueue.tryPut(rejectPolicy,task);
           }
       }
    }

    class Worker extends Thread{
         private Runnable task;
         public Worker(Runnable task){
             this.task=task;
         }
      //当task不为空，执行任务
        //task为空，从任务队列里获取任务并执行
        @Override
        public void run() {
              while (task!=null||(task=taskQueue.poll(timeout,timeUnit))!=null){
                  try {
                      log.debug("worker正在执行{}",task);
                      task.run();
                  } catch (Exception e) {
                      e.printStackTrace();
                  } finally {
                      task=null;
                  }
              }
              synchronized (workers){
                  log.debug("worker被移除{}",this);
                  workers.remove(this);
              }
        }
    }
}

/**
 * 模拟Blocking Queue
 * @param <T>
 */
@Slf4j(topic = "c.block")
class BlockingQueue<T>{
    //任务队列
     private Deque<T> deque=new ArrayDeque<>();
     //锁
    private ReentrantLock lock=new ReentrantLock();

    //生产者条件变量(队列满的时候等待)
    private Condition fullWaitSet = lock.newCondition();

    //消费者条件变量（队列空的时候等待）
    private Condition emptyWaitSet = lock.newCondition();

    // 5. 容量
    private int capcity;

    public BlockingQueue(int capcity){
        this.capcity=capcity;
    }

    /**
     * 带超时时间的阻塞获取
     * @return
     */
    public T poll(long timeout, TimeUnit unit){
        lock.lock();
        //为空的时候就一直等待
        try {
            //将时间统一为纳秒
            long nanos = unit.toNanos(timeout);
            while (deque.isEmpty()){
                try {
                    //解决虚假唤醒问题，在没有等待够就唤醒，等待时间应该是剩余的时间
                    //这个方法的返回值就是剩余时间
                    if(nanos<=0) return null;
                    nanos=emptyWaitSet.awaitNanos(nanos);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            //拿到队列头的元素
            T first = deque.removeFirst();
            fullWaitSet.signal(); //让消费者去拿
            return first;
        }finally {
            lock.unlock();
        }
    }

    //阻塞获取
    public T take(){
        lock.lock();
        //为空的时候就一直等待
        try {
            while (deque.isEmpty()){
                try {
                    emptyWaitSet.await();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            //拿到队列头的元素
            T first = deque.removeFirst();
            fullWaitSet.signal(); //让消费者去拿
            return first;
        }finally {
            lock.unlock();
        }
    }

    /**
     * 带超时时间的阻塞添加
     * @param
     */
    public boolean offer(T task,long timeout,TimeUnit timeUnit){
           lock.lock();
           try {
               long nanos = timeUnit.toNanos(timeout);
               while (deque.size()==capcity){
                   try {
                       log.debug("等待加入任务队列..{}",task);
                       if (nanos<=0) return false;
                       nanos=fullWaitSet.awaitNanos(nanos);
                   } catch (InterruptedException e) {
                       e.printStackTrace();
                   }
               }
               //拿到队列头的元素
               T first = deque.removeFirst();
               emptyWaitSet.signal(); //让消费者去拿
               return true;
           }finally {
               lock.unlock();
           }
    }

    //阻塞添加
    public void put(T element){
          lock.lock();
          try {
              //队列满的时候不能添加
              while(deque.size()==capcity){
                  try {
                      log.debug("等待加入任务队列");
                      fullWaitSet.await();
                  } catch (InterruptedException e) {
                      e.printStackTrace();
                  }
              }
              deque.addLast(element);
              log.debug("加入任务队列{}",element);
              emptyWaitSet.signal(); //唤醒生产者
          }finally {
              lock.unlock();
          }
    }

    //获取大小
    public int getSize(){
       lock.lock();
       try {
           return deque.size();
       }finally {
           lock.unlock();
       }
    }

   //拒绝策略
    public void tryPut(RejectPolicy<T> rejectPolicy, T task) {
        lock.lock();
        try {
             if (deque.size()==capcity){
                  rejectPolicy.reject(this,task);
             }else {
                 deque.addLast(task);
                 log.debug("加入任务队列{}",task);
                 emptyWaitSet.signal(); //唤醒生产者
             }
        }finally {
            lock.unlock();
        }
    }
}



```

# ThreadPoolExecutor

![image-20200917195229346](C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20200917195229346.png)

## 线程池状态

![image-20200917195510812](C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20200917195510812.png)

## 构造方法

```
public ThreadPoolExecutor(int corePoolSize,   int maximumPoolSize,                          long keepAliveTime,    TimeUnit unit,  BlockingQueue<Runnable> workQueue,                  ThreadFactory threadFactory,   RejectedExecutionHandler handler)

corePoolSize 核心线程数目 (最多保留的线程数)

maximumPoolSize最大线程数目

keepAliveTime 生存时间 - 针对救急线程 

unit 时间单位 - 针对救急线程 

workQueue 阻塞队列 

threadFactory 线程工厂 - 可以为线程创建时起个好名字 （在构造方法里加入一个实现即可）

handler 拒绝策略
```

![image-20200917224702094](C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20200917224702094.png)

![image-20200917224114774](C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20200917224114774.png)

## newFixedThreadPool

![image-20200917224924559](C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20200917224924559.png)

## newCachedThreadPool

![image-20200923142436544](C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20200923142436544.png)

```

核心线程数是 0， 最大线程数是 Integer.MAX_VALUE，救急线程的空闲生存时间是 60s，意味着全部都是救急线程（空闲后60s后可以回收）

救急线程可以无限创建

队列采用了 SynchronousQueue 实现特点是，它没有容量，没有线程来取是放不进去的（一手交钱、一手交货）
 
整个线程池表现为线程数会根据任务量不断增长，没有上限，当任务执行完毕，空闲 1分钟后释放线 程。 

适合任务数比较密集，但每个任务执行时间较短的情况
```

##  newSingleThreadExecutor 

```
如果在执行一个任务期间，出现了异常的那个情况，该线程池还会去创建一个新的线程来维持工作
```

![image-20200923143418211](C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20200923143418211.png)

## 提交任务

![image-20200923144025316](C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20200923144025316.png)

![image-20200923144043169](C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20200923144043169.png)

## 关闭线程

### shutdown

![image-20200923145208894](C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20200923145208894.png)

### shutdownNow

```
会打断正在执行的任务，并且将线程池状态设为STOP,并将队列中的任务返回
```

![image-20200923145250645](C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20200923145250645.png)

![image-20200923145300941](C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20200923145300941.png)

### 其他方法

![image-20200923145333166](C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20200923145333166.png)

# 异步模式之工作线程

## 饥饿

![image-20200923151225796](C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20200923151225796.png)

![image-20200923152823520](C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20200923152823520.png)

### 解决办法一：增加线程池 的大小(不是根本的解决方案)

### 解决方法二：不同的任务类型，使用不同的线程池

## 创建多大的线程池最合适？

```
过小会导致程序不能充分地利用系统资源、容易导致饥饿 

过大会导致更多的线程上下文切换，占用更多内存
```

### cpu密集型运算

```
通常采用 cpu 核数 + 1 能够实现最优的 CPU 利用率，+1 是保证当线程由于页缺失故障（操作系统）或其它原因 导致暂停时，额外的这个线程就能顶上去，保证 CPU 时钟周期不被浪费 
```

### I/O密集型运算

```
CPU 不总是处于繁忙状态，例如，当你执行业务计算时，这时候会使用 CPU 资源，但当你执行 I/O 操作时、远程 RPC 调用时，包括进行数据库操作时，这时候 CPU 就闲下来了，你可以利用多线程提高它的利用率。

线程数 = 核数 * 期望 CPU 利用率 * 总时间(CPU计算时间+等待时间) / CPU 计算时间

例如 4 核 CPU 计算时间是 50% ，其它等待时间是 50%，期望 cpu 被 100% 利用，套用公式
4 * 100% * 100% / 50% = 8


例如 4 核 CPU 计算时间是 10% ，其它等待时间是 90%，期望 cpu 被 100% 利用，套用公式
4 * 100% * 100% / 10% = 40
```

# 任务调度线程池

## 以前的Timer处理(有缺点)

```
在『任务调度线程池』功能加入之前，可以使用 java.util.Timer 来实现定时功能，

Timer 的优点在于简单易用，但 由于所有任务都是由同一个线程来调度，

因此所有任务都是串行执行的，同一时间只能有一个任务在执行，

前一个 任务的延迟或异常都将会影响到之后的任务
```

## ScheduledExecutorService

### 延时任务

![image-20200923155211620](C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20200923155211620.png)

### 定时任务

![image-20200923155505799](C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20200923155505799.png)

![image-20200923155911663](C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20200923155911663.png)

![image-20200923155943996](C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20200923155943996.png)

## 处理异常的方法

因为不会在控制台显示异常

### 主动捕捉加try .. catch..块

### 使用Future

get()方法执行的时候，就会把异常信息都打印出来

![image-20200923160606759](C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20200923160606759.png)

# 定期执行任务

![image-20200924154452254](C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20200924154452254.png)

# Tomcat线程池

![image-20200924160256842](C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20200924160256842.png)

```
LimitLatch 用来限流，可以控制大连接个数，类似 J.U.C 中的  Semaphore 后面再讲 

Acceptor 只负责【接收新的 socket 连接】 

Poller 只负责监听 socket channel 是否有【可读的 I/O 事件】 一旦可读，封装一个任务对象（socketProcessor），提交给 Executor 线程池处理 

Executor 线程池中的工作线程终负责处理请求
```

![image-20200924160451210](C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20200924160451210.png)

## connector配置

![image-20200924161123093](C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20200924161123093.png)

## Executor配置

![image-20200924161237681](C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20200924161237681.png)

# Fork&Join

```
Fork/Join 是 JDK 1.7 加入的新的线程池实现，它体现的是一种分治思想，适用于能够进行任务拆分的 cpu 密集型 运算
所谓的任务拆分，是将一个大任务拆分为算法上相同的小任务，直至不能拆分可以直接求解。跟递归相关的一些计 算，如归并排序、斐波那契数列、都可以用分治思想进行求解
Fork/Join 在分治的基础上加入了多线程，可以把每个任务的分解和合并交给不同的线程来完成，进一步提升了运 算效率
Fork/Join 默认会创建与 cpu 核心数大小相同的线程池
```

# JUC

## AQS

**不可重入锁**

![image-20200926132402892](C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20200926132402892.png)

# ReentrantLock原理(*************)![image-20200930123217353](C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20200930123217353.png)

## 非公平锁原理

## 锁重入原理

![image-20200930125642248](C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20200930125642248.png)

## 可打断原理

